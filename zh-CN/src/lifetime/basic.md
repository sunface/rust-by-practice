## ç”Ÿå‘½å‘¨æœŸåŸºç¡€

ç¼–è¯‘å™¨é€šè¿‡ç”Ÿå‘½å‘¨æœŸæ¥ç¡®ä¿æ‰€æœ‰çš„å€Ÿç”¨éƒ½æ˜¯åˆæ³•çš„ï¼Œå…¸å‹çš„ï¼Œä¸€ä¸ªå˜é‡åœ¨åˆ›å»ºæ—¶ç”Ÿå‘½å‘¨æœŸéšä¹‹å¼€å§‹ï¼Œé”€æ¯æ—¶ç”Ÿå‘½å‘¨æœŸä¹Ÿéšä¹‹ç»“æŸã€‚


## ç”Ÿå‘½å‘¨æœŸçš„èŒƒå›´
1. ğŸŒŸ
```rust,editable
/* ä¸º `i` å’Œ `borrow2` æ ‡æ³¨åˆé€‚çš„ç”Ÿå‘½å‘¨æœŸèŒƒå›´ */


// `i` æ‹¥æœ‰æœ€é•¿çš„ç”Ÿå‘½å‘¨æœŸï¼Œå› ä¸ºå®ƒçš„ä½œç”¨åŸŸå®Œæ•´çš„åŒ…å«äº† `borrow1` å’Œ `borrow2` ã€‚
// è€Œ `borrow1` å’Œ `borrow2` çš„ç”Ÿå‘½å‘¨æœŸå¹¶æ— å…³è”ï¼Œå› ä¸ºå®ƒä»¬çš„ä½œç”¨åŸŸæ²¡æœ‰é‡å 
fn main() {
    let i = 3;                                             
    {                                                    
        let borrow1 = &i; // `borrow1` ç”Ÿå‘½å‘¨æœŸå¼€å§‹. â”€â”€â”
        //                                                â”‚
        println!("borrow1: {}", borrow1); //              â”‚
    } // `borrow1` ç”Ÿå‘½å‘¨æœŸç»“æŸ. â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    {                                                    
        let borrow2 = &i; 
                                                        
        println!("borrow2: {}", borrow2);               
    }                                                   
}   
```

2. ğŸŒŸğŸŒŸ

**ç¤ºä¾‹**
```rust
{
    let x = 5;            // ----------+-- 'b
                          //           |
    let r = &x;           // --+-- 'a  |
                          //   |       |
    println!("r: {}", r); //   |       |
                          // --+       |
}                         // ----------+
```


```rust,editable
/* åƒä¸Šé¢çš„ç¤ºä¾‹ä¸€æ ·ï¼Œä¸º `r` å’Œ `x` æ ‡å‡†ç”Ÿå‘½å‘¨æœŸï¼Œç„¶åä»ç”Ÿå‘½å‘¨æœŸçš„è§’åº¦. */

fn main() {  
    {
        let r;                // ---------+-- 'a
                              //          |
        {                     //          |
            let x = 5;        // -+-- 'b  |
            r = &x;           //  |       |
        }                     // -+       |
                              //          |
        println!("r: {}", r); //          |
    }                         // ---------+
}
```

## ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨
Rust çš„å€Ÿç”¨æ£€æŸ¥å™¨ä½¿ç”¨æ˜¾å¼çš„ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨æ¥ç¡®å®šä¸€ä¸ªå¼•ç”¨çš„åˆæ³•èŒƒå›´ã€‚ä½†æ˜¯å¯¹äºç”¨æˆ·æ¥è¯´ï¼Œæˆ‘ä»¬åœ¨å¤§å¤šæ•°åœºæ™¯ä¸‹ï¼Œéƒ½æ— éœ€æ‰‹åŠ¨å»æ ‡æ³¨ç”Ÿå‘½å‘¨æœŸï¼ŒåŸå› æ˜¯ç¼–è¯‘å™¨ä¼šåœ¨æŸäº›æƒ…å†µä¸‹è‡ªåŠ¨åº”ç”¨ç”Ÿå‘½å‘¨æœŸæ¶ˆé™¤è§„åˆ™ã€‚

åœ¨äº†è§£ç¼–è¯‘å™¨ä½¿ç”¨å“ªäº›è§„åˆ™å¸®æˆ‘ä»¬æ¶ˆé™¤ç”Ÿå‘½å‘¨æœŸä¹‹å‰ï¼Œé¦–å…ˆè¿˜æ˜¯éœ€è¦çŸ¥é“è¯¥å¦‚ä½•æ‰‹åŠ¨æ ‡è®°ç”Ÿå‘½å‘¨æœŸã€‚


#### å‡½æ•°
**å¤§å®¶å…ˆå¿½ç•¥ç”Ÿå‘½å‘¨æœŸæ¶ˆé™¤è§„åˆ™**ï¼Œè®©æˆ‘ä»¬çœ‹çœ‹ï¼Œå‡½æ•°ç­¾åä¸­çš„ç”Ÿå‘½å‘¨æœŸæœ‰å“ªäº›é™åˆ¶:

- éœ€è¦ä¸ºæ¯ä¸ªå¼•ç”¨æ ‡æ³¨ä¸Šåˆé€‚çš„ç”Ÿå‘½å‘¨æœŸ
- è¿”å›å€¼ä¸­çš„å¼•ç”¨ï¼Œå®ƒçš„ç”Ÿå‘½å‘¨æœŸè¦ä¹ˆè·ŸæŸä¸ªå¼•ç”¨å‚æ•°ç›¸åŒï¼Œè¦ä¹ˆæ˜¯ `'static`

**ç¤ºä¾‹**
```rust,editable
// å¼•ç”¨å‚æ•°ä¸­çš„ç”Ÿå‘½å‘¨æœŸ 'a è‡³å°‘è¦è·Ÿå‡½æ•°æ´»å¾—ä¸€æ ·ä¹…
fn print_one<'a>(x: &'a i32) {
    println!("`print_one`: x is {}", x);
}

// å¯å˜å¼•ç”¨ä¾ç„¶éœ€è¦æ ‡å‡†ç”Ÿå‘½å‘¨æœŸ
fn add_one<'a>(x: &'a mut i32) {
    *x += 1;
}

// ä¸‹é¢ä»£ç ä¸­ï¼Œæ¯ä¸ªå‚æ•°éƒ½æ‹¥æœ‰è‡ªå·±ç‹¬ç«‹çš„ç”Ÿå‘½å‘¨æœŸï¼Œäº‹å®ä¸Šï¼Œè¿™ä¸ªä¾‹å­è¶³å¤Ÿç®€å•ï¼Œå› æ­¤å®ƒä»¬åº”è¯¥è¢«æ ‡è®°ä¸Šç›¸åŒçš„ç”Ÿå‘½å‘¨æœŸ `'a`ï¼Œä½†æ˜¯å¯¹äºå¤æ‚çš„ä¾‹å­è€Œè¨€ï¼Œç‹¬ç«‹çš„ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨æ˜¯å¯èƒ½å­˜åœ¨çš„
fn print_multi<'a, 'b>(x: &'a i32, y: &'b i32) {
    println!("`print_multi`: x is {}, y is {}", x, y);
}

// è¿”å›ä¸€ä¸ªé€šè¿‡å‚æ•°ä¼ å…¥çš„å¼•ç”¨æ˜¯å¾ˆå¸¸è§çš„ï¼Œä½†æ˜¯è¿™ç§æƒ…å†µä¸‹éœ€è¦æ ‡æ³¨ä¸Šæ­£ç¡®çš„ç”Ÿå‘½å‘¨æœŸ
fn pass_x<'a, 'b>(x: &'a i32, _: &'b i32) -> &'a i32 { x }

fn main() {
    let x = 7;
    let y = 9;
    
    print_one(&x);
    print_multi(&x, &y);
    
    let z = pass_x(&x, &y);
    print_one(z);

    let mut t = 3;
    add_one(&mut t);
    print_one(&t);
}
```

3. ğŸŒŸ
```rust,editable
/* æ·»åŠ åˆé€‚çš„ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨ï¼Œè®©ä¸‹é¢çš„ä»£ç å·¥ä½œ */
fn longest(x: &str, y: &str) -> &str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}

fn main() {}
```
4. ğŸŒŸğŸŒŸğŸŒŸ
```rust,editable
/* ä½¿ç”¨ä¸‰ç§æ–¹æ³•ä¿®å¤ä¸‹é¢çš„é”™è¯¯  */
fn invalid_output<'a>() -> &'a String { 
    &String::from("foo") 
}

fn main() {
}
```

5. ğŸŒŸğŸŒŸ
```rust,editable
// `print_refs` æœ‰ä¸¤ä¸ªå¼•ç”¨å‚æ•°ï¼Œå®ƒä»¬çš„ç”Ÿå‘½å‘¨æœŸ `'a` å’Œ `'b` è‡³å°‘å¾—è·Ÿå‡½æ•°æ´»å¾—ä¸€æ ·ä¹…
fn print_refs<'a, 'b>(x: &'a i32, y: &'b i32) {
    println!("x is {} and y is {}", x, y);
}

/* è®©ä¸‹é¢çš„ä»£ç å·¥ä½œ */
fn failed_borrow<'a>() {
    let _x = 12;

    // ERROR: `_x` æ´»å¾—ä¸å¤Ÿä¹…does not live long enough
    let y: &'a i32 = &_x;

    // åœ¨å‡½æ•°å†…ä½¿ç”¨ `'a` å°†ä¼šæŠ¥é”™ï¼ŒåŸå› æ˜¯ `&_x` çš„ç”Ÿå‘½å‘¨æœŸæ˜¾ç„¶æ¯” `'a` è¦å°
    // ä½ ä¸èƒ½å°†ä¸€ä¸ªå°çš„ç”Ÿå‘½å‘¨æœŸå¼ºè½¬æˆå¤§çš„
}

fn main() {
    let (four, nine) = (4, 9);
    

    print_refs(&four, &nine);
    // è¿™é‡Œï¼Œfour å’Œ nice çš„ç”Ÿå‘½å‘¨æœŸå¿…é¡»è¦æ¯”å‡½æ•° print_refs é•¿
    
    failed_borrow();
    // `failed_borrow`  æ²¡æœ‰ä¼ å…¥ä»»ä½•å¼•ç”¨å»é™åˆ¶ç”Ÿå‘½å‘¨æœŸ `'a`ï¼Œå› æ­¤ï¼Œæ­¤æ—¶çš„ `'a` ç”Ÿå‘½å‘¨æœŸæ˜¯æ²¡æœ‰ä»»ä½•é™åˆ¶çš„ï¼Œå®ƒé»˜è®¤æ˜¯ `'static`
}
```

#### Structs
6. ğŸŒŸ
```rust,editable
/* å¢åŠ åˆé€‚çš„ç”Ÿå‘½å‘¨æœŸæ ‡å‡†ï¼Œè®©ä»£ç å·¥ä½œ */

// `i32` çš„å¼•ç”¨å¿…é¡»æ¯” `Borrowed` æ´»å¾—æ›´ä¹…
#[derive(Debug)]
struct Borrowed(&i32);

// ç±»ä¼¼çš„ï¼Œä¸‹é¢ä¸¤ä¸ªå¼•ç”¨ä¹Ÿå¿…é¡»æ¯”ç»“æ„ä½“ `NamedBorrowed` æ´»å¾—æ›´ä¹…
#[derive(Debug)]
struct NamedBorrowed {
    x: &i32,
    y: &i32,
}

#[derive(Debug)]
enum Either {
    Num(i32),
    Ref(&i32),
}

fn main() {
    let x = 18;
    let y = 15;

    let single = Borrowed(&x);
    let double = NamedBorrowed { x: &x, y: &y };
    let reference = Either::Ref(&x);
    let number    = Either::Num(y);

    println!("x is borrowed in {:?}", single);
    println!("x and y are borrowed in {:?}", double);
    println!("x is borrowed in {:?}", reference);
    println!("y is *not* borrowed in {:?}", number);
}
```


7. ğŸŒŸğŸŒŸ
```rust,editable
/* è®©ä»£ç å·¥ä½œ */

#[derive(Debug)]
struct NoCopyType {}

#[derive(Debug)]
struct Example<'a, 'b> {
    a: &'a u32,
    b: &'b NoCopyType
}

fn main()
{ 
  let var_a = 35;
  let example: Example;
  
  {
    let var_b = NoCopyType {};
    
    /* ä¿®å¤é”™è¯¯ */
    example = Example { a: &var_a, b: &var_b };
  }
  
  println!("(Success!) {:?}", example);
}
```


8. ğŸŒŸğŸŒŸ
```rust,editable

#[derive(Debug)]
struct NoCopyType {}

#[derive(Debug)]
#[allow(dead_code)]
struct Example<'a, 'b> {
    a: &'a u32,
    b: &'b NoCopyType
}

/* ä¿®å¤å‡½æ•°çš„ç­¾å */
fn fix_me(foo: &Example) -> &NoCopyType
{ foo.b }

fn main()
{
    let no_copy = NoCopyType {};
    let example = Example { a: &1, b: &no_copy };
    fix_me(&example);
    println!("Success!")
}
```

## æ–¹æ³•
æ–¹æ³•çš„ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨è·Ÿå‡½æ•°ç±»ä¼¼ã€‚

**ç¤ºä¾‹**
```rust,editable
struct Owner(i32);

impl Owner {
    fn add_one<'a>(&'a mut self) { self.0 += 1; }
    fn print<'a>(&'a self) {
        println!("`print`: {}", self.0);
    }
}

fn main() {
    let mut owner = Owner(18);

    owner.add_one();
    owner.print();
}
```

9. ğŸŒŸğŸŒŸ
```rust,editable
/* æ·»åŠ åˆé€‚çš„ç”Ÿå‘½å‘¨æœŸè®©ä¸‹é¢ä»£ç å·¥ä½œ */
struct ImportantExcerpt {
    part: &str,
}

impl ImportantExcerpt {
    fn level(&'a self) -> i32 {
        3
    }
}

fn main() {}
```

## ç”Ÿå‘½å‘¨æœŸæ¶ˆé™¤( Elision )

æœ‰ä¸€äº›ç”Ÿå‘½å‘¨æœŸçš„æ ‡æ³¨æ–¹å¼å¾ˆå¸¸è§ï¼Œå› æ­¤ç¼–è¯‘å™¨æä¾›äº†ä¸€äº›è§„åˆ™ï¼Œå¯ä»¥è®©æˆ‘ä»¬åœ¨ä¸€äº›åœºæ™¯ä¸‹æ— éœ€å»æ ‡æ³¨ç”Ÿå‘½å‘¨æœŸï¼Œæ—¢èŠ‚çœäº†æ•²å‡»é”®ç›˜çš„ç¹çï¼Œåˆèƒ½æå‡å¯è¯»æ€§ã€‚

è¿™ç§è§„åˆ™è¢«ç§°ä¸ºç”Ÿå‘½å‘¨æœŸæ¶ˆé™¤è§„åˆ™( Elision )ï¼Œè¯¥è§„åˆ™ä¹‹æ‰€ä»¥å­˜åœ¨ï¼Œä»…ä»…æ˜¯å› ä¸ºè¿™äº›åœºæ™¯å¤ªé€šç”¨äº†ï¼Œä¸ºäº†æ–¹ä¾¿ç”¨æˆ·è€Œå·²ã€‚äº‹å®ä¸Šå¯¹äºå€Ÿç”¨æ£€æŸ¥å™¨è€Œè¨€ï¼Œè¯¥æœ‰çš„ç”Ÿå‘½å‘¨æœŸä¸€ä¸ªéƒ½ä¸èƒ½å°‘ï¼Œåªä¸è¿‡å¯¹äºç”¨æˆ·è€Œè¨€ï¼Œå¯ä»¥çœå»ä¸€äº›ã€‚


10. ğŸŒŸğŸŒŸ
```rust,editable
/* ç§»é™¤æ‰€æœ‰å¯ä»¥æ¶ˆé™¤çš„ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨ */

fn nput<'a>(x: &'a i32) {
    println!("`annotated_input`: {}", x);
}

fn pass<'a>(x: &'a i32) -> &'a i32 { x }

fn longest<'a, 'b>(x: &'a str, y: &'b str) -> &'a str {
    x
}

struct Owner(i32);

impl Owner {
    fn add_one<'a>(&'a mut self) { self.0 += 1; }
    fn print<'a>(&'a self) {
        println!("`print`: {}", self.0);
    }
}

struct Person<'a> {
    age: u8,
    name: &'a str,
}

enum Either<'a> {
    Num(i32),
    Ref(&'a i32),
}

fn main() {}
```
