# ä½¿ç”¨ as è¿›è¡Œç±»å‹è½¬æ¢
Rust å¹¶æ²¡æœ‰ä¸ºåŸºæœ¬ç±»å‹æä¾›éšå¼çš„ç±»å‹è½¬æ¢( coercion )ï¼Œä½†æ˜¯æˆ‘ä»¬å¯ä»¥é€šè¿‡ `as` æ¥è¿›è¡Œæ˜¾å¼åœ°è½¬æ¢ã€‚

1. ğŸŒŸ
```rust,editable
// ä¿®å¤é”™è¯¯ï¼Œå¡«ç©º
// ä¸è¦ç§»é™¤ä»»ä½•ä»£ç 
fn main() {
    let decimal = 97.123_f32;

    let integer: __ = decimal as u8;

    let c1: char = decimal as char;
    let c2 = integer as char;

    assert_eq!(integer, 'b' as u8);

    println!("Success!")
}
```

2. ğŸŒŸğŸŒŸ é»˜è®¤æƒ…å†µä¸‹, æ•°å€¼æº¢å‡ºä¼šå¯¼è‡´ç¼–è¯‘é”™è¯¯ï¼Œä½†æ˜¯æˆ‘ä»¬å¯ä»¥é€šè¿‡æ·»åŠ ä¸€è¡Œå…¨å±€æ³¨è§£çš„æ–¹å¼æ¥é¿å…ç¼–è¯‘é”™è¯¯(æº¢å‡ºè¿˜æ˜¯ä¼šå‘ç”Ÿ)
```rust,editable
fn main() {
    assert_eq!(u8::MAX, 255);
    // å¦‚ä¸Šæ‰€ç¤ºï¼Œu8 ç±»å‹å…è®¸çš„æœ€å¤§å€¼æ˜¯ 255.
    // å› æ­¤ä»¥ä¸‹ä»£ç ä¼šæŠ¥æº¢å‡ºçš„é”™è¯¯ï¼š literal out of range for `u8`.
    // **è¯·ä»”ç»†æŸ¥çœ‹ç›¸åº”çš„ç¼–è¯‘é”™è¯¯ï¼Œä»ä¸­å¯»æ‰¾åˆ°è§£å†³çš„åŠæ³•**
    // **ä¸è¦ä¿®æ”¹ main ä¸­çš„ä»»ä½•ä»£ç **
    let v = 1000 as u8;

    println!("Success!")
}
```

3. ğŸŒŸğŸŒŸ  å½“å°†ä»»ä½•æ•°å€¼è½¬æ¢æˆæ— ç¬¦å·æ•´å‹ `T` æ—¶ï¼Œå¦‚æœå½“å‰çš„æ•°å€¼ä¸åœ¨æ–°ç±»å‹çš„èŒƒå›´å†…ï¼Œæˆ‘ä»¬å¯ä»¥å¯¹å½“å‰æ•°å€¼è¿›è¡ŒåŠ å€¼æˆ–å‡å€¼æ“ä½œ( å¢åŠ æˆ–å‡å°‘ `T::MAX + 1` )ï¼Œç›´åˆ°æœ€æ–°çš„å€¼åœ¨æ–°ç±»å‹çš„èŒƒå›´å†…ï¼Œå‡è®¾æˆ‘ä»¬è¦å°† `300` è½¬æˆ `u8` ç±»å‹ï¼Œç”±äº`u8` æœ€å¤§å€¼æ˜¯ 255ï¼Œå› æ­¤ `300` ä¸åœ¨æ–°ç±»å‹çš„èŒƒå›´å†…å¹¶ä¸”å¤§äºæ–°ç±»å‹çš„æœ€å¤§å€¼ï¼Œå› æ­¤æˆ‘ä»¬éœ€è¦å‡å» `T::MAX + 1`ï¼Œä¹Ÿå°±æ˜¯ `300` - `256` = `44`ã€‚

```rust,editable
fn main() {
    assert_eq!(1000 as u16, __);

    assert_eq!(1000 as u8, __);

    // äº‹å®ä¸Šï¼Œä¹‹å‰è¯´çš„è§„åˆ™å¯¹äºæ­£æ•´æ•°è€Œè¨€ï¼Œå°±æ˜¯å¦‚ä¸‹çš„å–æ¨¡
    println!("1000 mod 256 is : {}", 1000 % 256);

    assert_eq!(-1_i8 as u8, __);
    

    // ä» Rust 1.45 å¼€å§‹ï¼Œå½“æµ®ç‚¹æ•°è¶…å‡ºç›®æ ‡æ•´æ•°çš„èŒƒå›´æ—¶ï¼Œè½¬åŒ–ä¼šç›´æ¥å–æ­£æ•´æ•°å–å€¼èŒƒå›´çš„æœ€å¤§æˆ–æœ€å°å€¼
    assert_eq!(300.1_f32 as u8, __);
    assert_eq!(-100.1_f32 as u8, __);
    

    // ä¸Šé¢çš„æµ®ç‚¹æ•°è½¬æ¢æœ‰ä¸€ç‚¹æ€§èƒ½æŸè€—ï¼Œå¦‚æœå¤§å®¶å¯¹äºæŸæ®µä»£ç æœ‰æè‡´çš„æ€§èƒ½è¦æ±‚ï¼Œ
    // å¯ä»¥è€ƒè™‘ä¸‹é¢çš„æ–¹æ³•ï¼Œä½†æ˜¯è¿™äº›æ–¹æ³•çš„ç»“æœå¯èƒ½ä¼šæº¢å‡ºå¹¶ä¸”è¿”å›ä¸€äº›æ— æ„ä¹‰çš„å€¼
    // æ€»ä¹‹ï¼Œè¯·å°å¿ƒä½¿ç”¨
    unsafe {
        // 300.0 is 44
        println!("300.0 is {}", 300.0_f32.to_int_unchecked::<u8>());
        // -100.0 as u8 is 156
        println!("-100.0 as u8 is {}", (-100.0_f32).to_int_unchecked::<u8>());
        // nan as u8 is 0
        println!("nan as u8 is {}", f32::NAN.to_int_unchecked::<u8>());
    }
}
```

4. ğŸŒŸğŸŒŸğŸŒŸ è£¸æŒ‡é’ˆå¯ä»¥å’Œä»£è¡¨å†…å­˜åœ°å€çš„æ•´æ•°äº’ç›¸è½¬æ¢
```rust,editable

// å¡«ç©º
fn main() {
    let mut values: [i32; 2] = [1, 2];
    let p1: *mut i32 = values.as_mut_ptr();
    let first_address: usize = p1 __; 
    let second_address = first_address + 4; // 4 == std::mem::size_of::<i32>()
    let p2: *mut i32 = second_address __; // p2 æŒ‡å‘ values æ•°ç»„ä¸­çš„ç¬¬äºŒä¸ªå…ƒç´ 
    unsafe {
        // å°†ç¬¬äºŒä¸ªå…ƒç´ åŠ  1
        __
    }
    
    assert_eq!(values[1], 3);

    println!("Success!")
}
```


5. ğŸŒŸğŸŒŸğŸŒŸ 
```rust,editable
fn main() {
    let arr :[u64; 13] = [0; 13];
    assert_eq!(std::mem::size_of_val(&arr), 8 * 13);
    let a: *const [u64] = &arr;
    let b = a as *const [u8];
    unsafe {
        assert_eq!(std::mem::size_of_val(&*b), __)
    }
}
```
